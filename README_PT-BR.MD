# Pudim Server

Cria√ß√£o de servidores HTTP simples, leves e customizaveis

> [!WARNING]
> Projeto experimental. APIs podem mudar sem aviso.

üá∫üá∏ [Read in English](README.md)

## sumario

- [sobre o que se trata](#sobre-o-que-se-trata)
- [dependencias](#dependencias)
- [Como funciona e como come√ßar?](#como-funciona-e-como-come√ßar)
  - [instala√ß√£o](#instala√ß√£o)
  - [Criando o servidor](#criando-o-servidor)
  - [Criando Rotas](#criando-rotas)
  - [Iniciando o servidor](#iniciando-o-servidor)
  - [Objeto Request](#objeto-request)
  - [Objeto Response](#objeto-response)
  - [Customizando o wrapper do client](#customizando-o-wrapper-do-client)
- [Exemplo completo](#exemplo-completo)
- [Roadmap](#roadmap)
- [Licen√ßa](#licen√ßa)
- [Contribuindo](#contribuindo)

## sobre o que se trata?

Atualmente Pudim Server √© um lib lua focada em fazer APIs simples para cria√ß√£o de servidores web, com um sistema de rotas. feito para aceitar requis√ß√µes HTTP e interpretar, despachar para um handler e devolver uma resposta.

Essa lib esta sendo projetada com base no que [Davi](https://github.com/pessoa736) entende de **servidor**. Ele pretende expandir a lib para algo mais complexo com o tempo, mas mantendo em foco a simplicidade, leveza e customiza√ß√£o.

## dependencias

- lua >= 5.4
- luaSocket
- lua-cjson

## Como funciona e como come√ßar?

### instala√ß√£o

primeiramente para poder rod√°-lo precisamos instala-lo, e para isso no usaremos o luarocks

```sh
# instala√ß√£o local
luarocks install PudimServer --local


# instala√ß√£o global
sudo luarocks install PudimServer
```

### Criando o servidor

agora criaremos um arquivo para o servidor nomeremos de `Server.lua` para importar o PudimServer e configura-lo para criar-mos o servidor.

```lua
local PudimServer = require("PudimServer") --importando o PudimServer

local MyServer = PudimServer:Create{
    ServiceName = "nome do Servi√ßo",  -- auto-explicativo, √© o nome do servi√ßo.
    Port = 8080,                      -- porta que o servidor va ser aberto.
    Address = "localhost",            -- ou quaquer endere√ßo mapeado pela sua maquina.
    wrapClientFunc = function(Server) -- para o tratamento customizado para o client, caso n√£o use pode deixar como nil.

        --- aqui vc pode organizar o servidor para usar SSL ou TSL com adi√ß√£o de outras libs, ou o que quiser fazer.
        local client = Server:accept()
        return client
    end
}

local MyServer = PudimServer:Create() -- assim ele cria o server com a configura√ß√£o padr√£o
```

### Criando Rotas

a cria√ß√£o de rotas segue algo parecido com o next.js onde vc criar uma fun√ß√£o para tratar os diferentes tipos de requis√ß√£o para a rota e retorna respostas.

no PudimServer utilizamos o fun√ß√£o Routes, ela recebe primeiramente a rota com string e depois 
a fun√ß√£o que trata a resposta da requis√£o dela

- exemplo de uma pagina html:

```lua
MyServer:Routes(
    "/", -- rota 
    function (req, res)
        if req.method == "GET" then --- tipo da requisi√ß√£o
            
            return res:response(
                200, -- status
                     -- body
                [[
                    <html>
                        <body>
                            <h1>MyServer</h1>
                        </body>
                    </html>
                ]], 
                {   -- headers
                    ["Content-Type"] = "text/html"
                }
            )
        
        end

        return res:response(400, {msg = "metodo n√£o √© valido"}) -- caso n√£o seja enviado menhuma resposta
  end
)
```

- exemplo de uma API JSON:

```lua
MyServer:Routes(
    "/api/users",
    function (req, res)
        if req.method == "GET" then
            local users = {
                {id = 1, name = "Jo√£o"},
                {id = 2, name = "Maria"}
            }
            return res:response(200, users) -- tabelas s√£o automaticamente convertidas para JSON
        end

        if req.method == "POST" then
            -- processar o body da requisi√ß√£o
            local data = req.body
            return res:response(200, {msg = "Usu√°rio criado!", data = data})
        end

        return res:response(400, {error = "M√©todo n√£o suportado"})
    end
)
```

### Iniciando o servidor

ap√≥s criar as rotas, basta chamar o m√©todo `Run` para iniciar o servidor:

```lua
MyServer:Run() -- o servidor ficar√° rodando e escutando requisi√ß√µes
```

### Objeto Request

O objeto `req` passado para o handler cont√©m as seguintes propriedades:

| Propriedade | Tipo | Descri√ß√£o |
|-------------|------|-----------|
| `method` | string | M√©todo HTTP (GET, POST, PUT, DELETE, etc) |
| `path` | string | Caminho da requisi√ß√£o (ex: "/api/users") |
| `version` | string | Vers√£o do HTTP (ex: "HTTP/1.1") |
| `headers` | table | Headers da requisi√ß√£o (chaves em lowercase) |
| `body` | string | Corpo da requisi√ß√£o |

### Objeto Response

O m√©todo `res:response()` recebe os seguintes par√¢metros:

| Par√¢metro | Tipo | Obrigat√≥rio | Descri√ß√£o |
|-----------|------|-------------|-----------|
| `status` | number | ‚úÖ | C√≥digo de status HTTP (200, 404, 500, etc) |
| `body` | string/table | ‚úÖ | Corpo da resposta. Se for uma table, ser√° convertido para JSON |
| `headers` | table | ‚ùå | Headers customizados da resposta |

### Customizando o wrapper do client

O `wrapClientFunc` permite customizar como o cliente √© tratado, √∫til para implementar SSL/TLS:

```lua
local MyServer = PudimServer:Create{
    ServiceName = "Servidor Seguro",
    Port = 443,
    Address = "0.0.0.0",
    wrapClientFunc = function(Server)
        local client = Server:accept()
        -- aqui voc√™ pode wrappear o client com SSL
        -- exemplo: client = ssl.wrap(client, params)
        return client
    end
}

-- ou definir depois:
MyServer:SetWrapClientFunc(function(Server)
    return Server:accept()
end)
```

## Exemplo completo

```lua
local PudimServer = require("PudimServer")

local MyServer = PudimServer:Create{
    ServiceName = "Minha API",
    Port = 3000,
    Address = "localhost"
}

-- Rota principal
MyServer:Routes("/", function(req, res)
    if req.method == "GET" then
        return res:response(200, "<h1>Bem-vindo!</h1>", {["Content-Type"] = "text/html"})
    end
    return res:response(405, {error = "M√©todo n√£o permitido"})
end)

-- API de dados
MyServer:Routes("/api/data", function(req, res)
    if req.method == "GET" then
        return res:response(200, {
            status = "ok",
            timestamp = os.time(),
            message = "API funcionando!"
        })
    end
    return res:response(405, {error = "M√©todo n√£o permitido"})
end)

-- Inicia o servidor
print("Servidor rodando em http://localhost:3000")
MyServer:Run()
```

## Roadmap

> [!NOTE]
> Este projeto est√° em fase experimental. Confira abaixo o que j√° foi implementado e o que est√° planejado.

### ‚úÖ Implementado

- [x] Sistema de rotas b√°sico
- [x] Parsing de requisi√ß√µes HTTP (method, path, headers, body)
- [x] Respostas JSON autom√°ticas (tables convertidas para JSON)
- [x] Customiza√ß√£o do wrapper do client (`wrapClientFunc`)
- [x] Sistema de logs configur√°vel

### Planejado

- [ ] Rotas din√¢micas com par√¢metros (`/users/:id`, `/posts/:slug`)
- [ ] Parsing autom√°tico de query strings (`?page=1&limit=10`)
- [ ] Sistema de middleware para interceptar requisi√ß√µes
- [ ] Helpers para CORS (Cross-Origin Resource Sharing)
- [ ] Mais c√≥digos de status HTTP mapeados
- [ ] Suporte a uploads de arquivos (multipart/form-data)
- [ ] Servir arquivos est√°ticos (HTML, CSS, JS, imagens)
- [ ] Rate limiting b√°sico

### Futuro 

- [ ] Suporte a WebSockets
- [ ] Multi-threading / concorr√™ncia
- [ ] HTTPS nativo (sem precisar de wrapper externo)
- [ ] Hot reload em desenvolvimento
- [ ] CLI para criar projetos

## Licen√ßa

Este projeto est√° sob a licen√ßa MIT. Veja o arquivo [LICENSE](LICENSE) para mais detalhes.

## Contribuindo

Contribui√ß√µes s√£o bem-vindas! Veja o guia completo em [CONTRIBUTING_PT-BR.MD](CONTRIBUTING_PT-BR.MD).

---

Feito com ‚ù§Ô∏è por [Davi](https://github.com/pessoa736)
